#define _CRT_SECURE_NO_WARNINGS 1;
#include <string.h>

//整型分类
/*
*   char
*		unsigned char (无符号)
*		signed char
*   short
*		unsigned short [int] (无符号)
*		signed short [int]
*   int
*		unsigned int (无符号)
*		signed int
*	long
*		unsigned long [int](无符号)
*		signed long [int]
*
****/
//浮点型
// float  （单精度）
// double  （双）

//构造类型 - 自定义类型
// 数组类型
// 结构体类型 struct
// 枚举类型   enum
// 联合类型   union

//指针类型
// int *pi
// char *pc
// float *pf
// void *pv

//空类型
// void 表示空类型（无类型）
// 通常应用于函数的返回类型，函数的参数；指针类型
// void test（）函数返回类型 

//为什么补码存放更加适合；
///因为换算更加合理； 补码可以将符号位和数值域统一处理；（符号位和数值可以一起运算）    
/// 且按照获得补码的顺序 对 补码运算；可以得到原码
//  计算机中只有加，其他的都是模拟出来的 1+（-1）  等于 1-1
//1的补码
// 0000000000000000000000000000000000001
//-1的补码
// 1111111111111111111111111111111111111
// 1+（-1） =0   =》 1000000000000000000000000000000000000 （多一位，截取）
//          0         000000000000000000000000000000000000   

// 整形在内存中怎么存放的
//整数二进制有三种形式：原码，反码，补码；
//正整数 相同  原码=反码=补码；
//负整数 原码  反码（符号位不变，其他取反）  补码（反码加一）
// -10
// 10000000  00000000  00000000  00001010
// 11111111  11111111  11111111  11110101
// 1111 1111 1111 1111 1111 1111 1111 0110 
//  F    F     F    F    F   F    F    6
//  f6 ff ff ff   (十六进制，四位二进制一体)     为什么是倒着存储的呢？？？？？？？？？？？？？？
// 高位字节序 ff
// 低位字节序 f6  
//  F(1+2+4+8)

///大端（大的相反）小端（小的一样）字节序：
//0x11223344
// 大端字节序：将数据 低位字节序的内容 放到 高地址处；高位字节序的内容 放到 低地址处； 低 11（高位字节序） 22 33 44（低位字节序） 高
// 小端字节序：将数据 低位字节序的内容 放到 低地址处；高位字节序的内容 放到 高地址处； 低 44             33 22 11             高  

///题目
//请简述大小端字节序的概念； 设计一个程序；判断当前机器的字节序  
// 二进制补码 ：ff ff ff f6  （字节序高到低）
//大端字节序： 低位字节序  放后  高位字节序 放前；  正序  ff ff ff f6  
//小端字节序； 低位字节序  放前  高位字节序 放后；  倒序  f6 ff ff ff
//int check_key(void) {
//	int a = 1;
//	//00000000 00000000 00000000 00000001
//	// 00 00 00 01  =》  看低字节位（01）得位置在前还是在后；
//	//					后  大端
//	//					前  小端
//	//(char*)强制转换   a为整形；想要存储在char* 中需要转换
//	char* p = (char*)&a;  //只拿去a中的第一个字节
//	///
//	// 00 00 00 01   大端   低字节位内容 在 高地址处
//	// 01 00 00 00   小端   低字节位内容 在 低地址处
//	return *p;  // 1 低字节位内容 在 低地址处
//				// 0 高字节位内容 在 高地址处
//}
//
//int main(void) {
//	int ret = check_key();
//	if (ret) {
//		printf("小端、\n");
//	}
//	else {
//		printf("大端、\n");
//	}
//
//	return 0;
//}

/// 输出结果 （1）
//int main(void) {
//	char a = -1;
//	// 1000 0001 原码
//	// 1111 1110 反码
//	// 1111 1111 补码
//	// %d 打印 =》 整型提升  看符号位 1=》1  0=》0
//	// 11111111 11111111 11111111 11111111  补码
//	// 11111111 11111111 11111111 11111110	反码
//	// 10000000 00000000 00000000 00000001  原码 输出！  -1
//	signed char b= -1;
//	// 1111 1111 补码   一样
//
//	unsigned char c= -1;   //无符号 的 符号位为0
//	// 1111 1111 补码
//	// 符号位为0
//	// %d 打印 =》 整型提升  看符号位 1=》1  0=》0
//	// 00000000 00000000 00000000 11111111  补码   （最高位为0  正数 ；原反补相同）
//	//								255		输出   
//	 
//	//输出什么：
//	printf("a=%d\nb=%d\nc=%d\n", a, b, c);
//	//%d 十进制整型输出； 整形提升；
//
//	//补充
//	//1.int  是 signed int
//	//2.short  是 signed short
//	
//	//3.char 是 signed char  （大多数！不绝对）
//
//	return 0;
//}


///（2）
//int main(void) {
//	char a = -128;
//	//10000000 00000000 00000000 10000000; 原码
//	//11111111 11111111 11111111 01111111; 反码
//	//11111111 11111111 11111111 10000000  补码   
//	// 10000000  -128
//	// 整型提升：
//	// 11111111 11111111 11111111 10000000 补    //%u  最高位就不是符号位了； 那就原反补；
//	
/////char类型取值范围！ -128  0  127  
//	///  在内存中  -128 -> 0 -> 127 -> -1 ->  -128（这样轮回的一个圆,下面证明！）
//	char a2 = 128;  //这里的128等于 127+1  
//					// 01111111  = 127
//					// 11111111  = -127 (补码)
//					// 11111110（补码）
//					// 10000001 （原码）
//					// -1
//	//00000000 00000000 00000000 10000000; 原码  （原反补相同）
//	//10000000  
//	//%u （无符号整形输出） 整型提升
//	//11111111 11111111 11111111 10000000；  补码 （无符号数出；原码反码补码一样）
//	//11111111 11111111 11111111 01111111；  反码
//	//10000000 00000000 00000000 10000000；  原码  %d输出=》-128
//
//	// %u(无符号整形打印) 输出 =》 
//	printf("%u\n", a);  //
//	printf("%u\n", a2);  //
//	printf("%d\n", a);  //-128
//	printf("%d\n", a2);  //-128
//
//	return 0;
//}

///（4）
//int main(void) {
//	int i = -20;
//	//10000000 00000000 00000000 00010100 
//	//11111111 11111111 11111111 11101011
//	//11111111 11111111 11111111 11101100 (补)
//	//
//	unsigned int j = 10;
//	//00000000 00000000 00000000 00001010
//	// %d 有符号的十进制数打印
//	// %u 无符号的十进制数打印
//	//i+j
//	//11111111 11111111 11111111 11110110 （补）
//	//11111111 11111111 11111111 11110101 （反）
//	//10000000 00000000 00000000 00001010  (原码）  -10
//
//	printf("%d\n", i + j);
//	return 0;
//}


///（5）
//#include <stdio.h>
//int main(void) {
//	///1
//	//unsigned int i;
//	//for (i = 9; i >= 0; i--) {
//	//	//9 ->  00000000000000000000000000001001
//	//	// ......
//	//	//0 - > 00000000000000000000000000000000
//	//	//-1 -> 10000000000000000000000000000001(原码)
//	//	//		11111111111111111111111111111110（反）
//	//	//		11111111111111111111111111111111 (补）	->unsigned！！ 无视符号位！
//	//	//  补码（原反补） =》4,294,967,295
//	//	printf("%u\n", i);
//	//}
//	///2
//	//char a[1000];
//	//int i;
//	//for (i = 0; i < 1000; i++) {
//	//	a[i] = -1 - i;
//	//}
//	////255
//	////00000000 00000000 00000000 11111111
//	////-1-i
//	//// char=》 00000000
//	//// 0 == '/0'  结束字符
//	//
//	////所以到了 下标255 的时候 存的 ‘0’  被解析为‘\0’;     
//	////255
//
//	////8位存储巧记  超出范围数据 ：正数-256  负数+256
//	////128+127 = 255
//	////-1 ~ -128 127 ~ 1  0
//	//printf("%d", strlen(a));
//	///3
//	unsigned char i = 0;
//	//0倒255  i=256的时候 补码 00000000 00000000 00000001 00000000 
//	//						  00000000   =》 0 < 255
//	for (i = 0; i <= 255; i++) {
//		printf("hello world\n");
//	}
//	return 0;
//}

///（6） 
//int short char  limits.h定义整型家族的取值范围
//float double    float.h 定义浮点型家族的取值范围
#include <limits.h>
#include <float.h>
//int main(void) {
//	//整型
//	INT_MAX;  //转倒定义
//
//	//浮点型  DIG  精度
//	FLT_MAX;
//	DBL_MAX;
//	return 0;
//}

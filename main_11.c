#define _CRT_SECURE_NO_WARNINGS 1;
#include <stdio.h>
#include <string.h>

////算数操作符 + - * / %
//int main(void) {
//	////整数除法
//	//int a = 3 / 5;
//
//	////小数除法  5.0被默认为double  加f 就可以转换为float的类型
//	//float a2 = 5.0f / 6;
//
//	//printf("%d\n", a);
//	//printf("%d", a2);
//
//	//取%   只能是整数,小数报错；
//	int a = 7 % 3;
//	printf("%d", a);
//	return 0;
//}


////位移操作符  >>  <<  不改变源数据
//int main(void) {
//	int a = 10;
//	//把a的二进制向左移动一位； int -> 4B ->4B * 8b = 32b
//	//a = 00000000 00000000 00000000 0000 1010
//	//b = << a = 00000000 00000000 00000000 0   0  0  1  0 1 0 0; 
//	//										128 64 32 16 8 4 2 0	
//	// 16+4 = 20
//
//	int b = a << 1;
//
//	//c = << a = 00000000 00000000 00000000 0000 0101; 
//	// 4 + 1
//	int c = a >> 1;
//	 //右移，符号位补全（正：0；负：1）；右边舍弃
//
//	printf("b = %d\n", b);
//	printf("c = %d\n", c);
//	return 0;
//}

////按位操作符  &（按位与） |（按位或） ^（按位异或） 2进制位  操作数位整数 
// 符号为也会考虑
//int main(void) {
//	int a = 10;
//	int b = 13;
//	// a= 00000000 00000000 00000000 0000 1010;
//	// b= 00000000 00000000 00000000 0000 1101;
//	int c = a & b;
//	// 对位 0 0 -》0    0 1-》0    1 1-》1
//	// c= 00000000 00000000 00000000 0000 1000;   => 8
//
//	int c2 = a | b;
//	// 对位 0 0 -》0    0 1-》1    1 1-》1
//	// c= 00000000 00000000 00000000 0000 1111;   => 15
//
//	int c3 = a ^ b;
//	// 对位 0 0 -》0    0 1-》1    1 1-》0   相同位0；相异位1
//	// c= 00000000 00000000 00000000 0000 0111;   => 7
//
//	printf("c = %d\n", c);
//	printf("c2 = %d\n", c2);
//	printf("c3 = %d\n", c3);
//
//	//交换两个数  
//	int num1 = 3;
//	int num2 = 5;
//	printf("num1=> %d -- num2=> %d\n", num1, num2);
//	//溢出  坏处！
//	/*num2 = num2 - num1;
//	num1 = num2 + num1;
//	num2 = num1 - num2;*/
//	printf("num1=> %d ++ num2=> %d\n", num1, num2);
//
//
//	printf("num1=> %d -- num2=> %d\n", num1, num2);
//	//推荐！  0 ^ 3=3  3^3 =0
//	//(3^5)^3 = 3    3^(3^5) = 5     
//	// (3^5）中间码    3^中间码 =5   5^中间码 =3
//	num2 = num1 ^ num2;// num2 = 011 ^ 101 => 110    
//	num1 = num1 ^ num2;// num1 = 101 ^ 110 => 011		
//	num2 = num1 ^ num2;// num2 = 011 ^ 110 => 101
//	printf("num1=> %d ++ num2=> %d\n", num1, num2);
//
//	return 0;
//}

//// 赋值操作符 = += -= *= /= <<=  >>= %= &= ^= |=
//int main(void) {
//	int a = 13;
//
//	int x =0,y = 7,c=9;
//	c = x = y + 1;  // c=x=8   建议拆开写；
//	printf("c=%d  --  y=%d", c,x);
//}


//// 单目操作符 ！ - + &(取地址) *（解地址） sizeof ~（按位取反） ++ -- （类型）
//int main(void) {
//	int flag = 5;
//	//flag = !flag;
//	if (flag) {
//		printf("true:%d\n", flag); //5
//	}
//	else {
//		printf("true:%d\n", flag);   //0
//
//	}
//
//
//	short s = 5;
//	int a = 10;
//	printf("%d\n", sizeof(s = a + 2)); //sizeof括号中的表达式不参与运算；
//	printf("%d\n", s);
//
//
//	//test
//	int as = 13;
//	as = as | (1 << 4);
//	/***
//	* 1 => 00000000 00000000 00000000 00000001
//	* 1<<4  =		00000000 00000000 00000000 00010000  四位
//	*
//	* 13=>			00000000 00000000 00000000 00001101
//	* 13 | (1<<4)	00000000 00000000 00000000 00011101 29
//	**/
//	printf("as | (1 << 4) = %d\n", as);
//
//	as = as & ~(1 << 4);
//	/**
//	* 1<<4  =		00000000 00000000 00000000 00010000
//	* ~(1<<4) =		11111111 11111111 11111111 11101111
//	*
//	*
//	* 13=>			00000000 00000000 00000000 00001101
//	* 13 & ~(1 << 4)00000000 00000000 00000000 00001101   13
//	**/
//	printf(" as & ~(1 << 4) = %d\n", as);
//
//
//
//	//奇怪的代码
//	int num1 = 1;
//	int num2 = (++num1) + (++num1) + (++num1);
//	printf("%d\n", num2);
//
//
//	//& 取地址  *拿值
//	int demo = 10;
//	printf("%p\n", &demo);
//	int* pDemo = &demo;
//	*pDemo = 20;  // * - 取地址
//	printf("%d\n", demo);
//
//	//(类型)  强转换
//	int nums = (int)3.14;
//	printf("%d\n", nums);
//	
//	return 0;
//}

//数组作为参数传入函数中； 传入的是数组第一个元素的地址（指针）  32位 4B  64位 8B

//// ==  两个字符不能使用这个判断相等； 
//// &&  与
//// ||  或 
//
//int main(void){
//	int i = 0, a = 0, b = 2, c = 3, d = 4;
//	//i = a++ && ++b && d++;// a为假后面就会算了
//	i = a++ || ++b || d++;   //为真了；后面就不算了
//	printf("a=%d\nb=%d\nc=%d\nd=%d\n", a, b, c, d);
//	return 0;
//}

////三目运算  逗号表达式（从左向右依次计算，整个表达式，是最后一个表达式的结果）
//int main(void) {
//	int a = 3;
//	int b = 5;
//	int c = 0;
//	int d = (c = 5, a = c + 3, b = a - 4, c += 5);
//	//			5      8         4           10  =>d=10
//	printf("d=%d", d);
//
//
//	//应用
//	a = get_val();
//	count_val(a);
//	while(a > 0)
//	{
//		//业务处理
//		a = get_val();
//		count_val(a);
//	}
//
//	//优化  等同于上面的代码
//	while (a = get_val(),count_val(a),a > 0)
//	{
//		//业务处理
//	}
//
//	return 0;
//}


//[] 下标  () 函数调用操作符

//int main(void) {
//	int arr[10] = { 1,2,3,4,5,6,7,8,9 };
//	prtinf("%d\n", arr[4]);
//	return 0; 
//}

//结构体   允许我们自己定义一个类型
	/**
	* 书，书名，书号，出版社
	* 人，名字，年龄，性别
	*
	**/
	//结构体成员访问操作符
	//.
	//->
//自定义类型
//struct Book   //struct  结构体名{  属性定义 }
//{
//	char name[20];
//	char id[20];
//	int price;
//};
//int main(void) {
//	int num = 10;
//	//初始化 
//	//struct Book b = {val}
//	struct Book b = { "Fuck","c12345649687",55 };
//
//	printf("书名=%s\n编号=%s\n价格=%d\n", b.name,b.id,b.price);
//
//	struct Book * pb= &b;
//	printf("书名=%s\n编号=%s\n价格=%d\n", (*pb).name, (*pb).id, (*pb).price);
//
//	// ->指向   pb指向结构体的name
//	printf("书名=%s\n编号=%s\n价格=%d\n", pb->name, pb->id, pb->price);
//	return 0; 
//}


////隐式转换；   为什么要整形提升呢？    cpu的运算器的操作数字节长度为int字节长度；
//int main(void) {
//	//1.正数（负数）转换为二进制补码；
//	//2.整形提升  为0（无符号）=>0  为1=>1    
//	//3.计算；之后截断；  ()
//		//输出；
//	// 4.  =>2
//	// 5打印  => 源码
//
//
//	char a, b, c;
//	b = 'b';
//	// 01100010
//	//提升
//	// 00000000 00000000 00000000 01100010
//	c = 'c';
//	// 01100011
//	//提升
//	// 00000000 00000000 00000000 01100011
//	
//	//先执行转换为int ；再计算； 将结果截断；存储与a中；
//	a = b + c;   
//	// 00000000 00000000 00000000    01100010
//	// 00000000 00000000 00000000    01100011
//	// => 00000000 00000000 00000000 11000101
//	// 截断 11000101
//		
//	printf("a=%d\n", a);  //-59
//	// 11111111 11111111 11111111 11000101 （补）
//	// 11111111 11111111 11111111 11000100
//	// 10000000 00000000 00000000 00111011  （源）    -59
//
//	//为正数，正反补都一样；
//	//负数就要处理了
//	char num1 = 3;
//	//000000011
//	//整形提升： 补码按照符号为来 为0（无符号）；补0
//	//00000000 00000000 00000000 00000011
//	char num2 = 127;
//	//01111111
//	// 整形提升： 补码按照符号为来 为1；补1
//	//00000000 00000000 00000000 01111111
//	char num3 = num1 + num2;
//	//00000000 00000000 00000000 00000011
//	//00000000 00000000 00000000 01111111
//	//=> 00000000 00000000 00000000 10000010
//	//截断 100000010  （负数）
//	printf("num3=%d\n", num3);  //
//	// 打印输出位int输出；再次整形提升
//	// 11111111 11111111 11111111 100000010 （补）
//	// 11111111 11111111 11111111 100000001 （反）（取反符号位不变）
//	// 10000000 00000000 00000000 011111110	 (源）   -126
//
//	//例题
//	char s1 = 0xb6;
//	short s2 = 0xb600;
//	int s3 = 0xb6000000;
//	if (s1 == 0xb6) {
//		printf("a\n");
//	}
//	if (s2 == 0xb600) {
//		printf("b\n");
//	}
//	if (s3 == 0xb6000000) {
//		printf("c\n");
//	}
//
//	char val = 1;
//	printf("%u\n", sizeof(val)); // 1   sizeof（）  输出是计算后的值
//	printf("%u\n", sizeof(+val)); // 4
//	printf("%u\n", sizeof(-val)); // 4
//	printf("%u\n", sizeof(!val)); // 4  gcc为准
//
//	return 0;
//}

//算术转换   转换遵循向上转换  比长度；相同长度比精度
/**
*  long double
*  double
*  float  （精度更高于int）
*  unsigned long int 
*  long
*  unsigned int 
*  int      
 **/


//操作符的属性
//复杂表达式求值有三个影响的因素。
/**
* 1.操作符优先级  (仅仅取0决于部分)   
*	(表达式)  函数掉用（）  数组下标引用[]  访问结构成员.  访问结果指针的成员 ->
*    val++   val--  ！（逻辑反）  ~（按位取反）  + -   ++val  --val
*    *（解地址）   &（取地址）    sizeof()  （类型）   
*    *（乘）   /  %  +   -   <<  >>   >  >=  >  <= == !=  
*    &(位与 11为1)  ^（位异或 相同为0 相异为1）  |（位或 有1为1）
*	 && || ?:(条件、三目操作符)  =  +=  -=  *=  /=  %= <<=  >>=  &=  ^=  |= 
*    ,
* 
* 2.操作符的结合性
* 3.是否控制求值顺序
* 
*  两个相邻的操作符先执行哪个？
*		取决于他们的优先级；
*（优先级相同）取决于他们的结合性
**/
//int fun()
//{
//	//创建后，不会被销毁
//	static int count = 1;
//	return ++count;
//}
//int main()
//{
//	int answer;
//	//不知道哪个函数会先被掉用
//	answer = fun() - fun() * fun();
//	printf("%d\n", answer);//输出多少？
//	return 0;
//}

//转为汇编  运行 右击-转汇编；
//int main()
//{
//	int i = 1;
//	int ret = (++i) + (++i) + (++i);
//	printf("%d\n", ret); //12
//	printf("%d\n", i);//4
//
//	return 0;
//}


